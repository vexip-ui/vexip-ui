<template>
  <Select
    :id="idFor"
    ref="select"
    v-model:visible="visible"
    :class="nh.b()"
    :list-class="nh.be('list')"
    :value="currentValue"
    :size="props.size"
    :state="props.state"
    :clearable="props.clearable"
    :transition-name="props.transitionName"
    :disabled="props.disabled"
    :transfer="props.transfer"
    :placement="props.placement"
    :prefix-color="props.prefixColor"
    :suffix-color="props.suffixColor"
    :no-suffix="!hasSuffix"
    :placeholder="props.placeholder"
    :options="props.options"
    :key-config="{ ...props.keyConfig, label: props.keyConfig.value || 'value' }"
    @toggle="handleToggle"
    @select="handleSelect"
    @clear="handleClear"
    @focus="control?.focus()"
    @blur="control?.blur()"
  >
    <template v-if="hasPrefix" #prefix>
      <slot name="prefix">
        <Icon :icon="props.prefix"></Icon>
      </slot>
    </template>
    <template #control>
      <slot
        name="control"
        :value="currentValue"
        :on-input="handleInput"
        :on-change="handleChange"
        :on-enter="handleEnter"
        :on-clear="handleClear"
      >
        <input
          ref="control"
          :class="nh.be('input')"
          :autofocus="props.autofocus"
          :spellcheck="props.spellcheck"
          :disabled="props.disabled"
          :placeholder="props.placeholder ?? locale.placeholder"
          autocomplete="off"
          tabindex="-1"
          @input="handleInput"
          @change="handleInputChange"
          @keyup.enter="handleEnter"
          @keydown="handleKeyDown"
        />
      </slot>
    </template>
    <template v-if="hasSuffix" #suffix>
      <slot name="suffix">
        <Icon :icon="props.suffix"></Icon>
      </slot>
    </template>
    <template #default="{ option, index, selected }">
      <slot
        :option="option"
        :index="index"
        :selected="selected"
        :handle-select="handleSelect"
      ></slot>
    </template>
  </Select>
</template>

<script lang="ts">
import { defineComponent, ref, computed, watch, watchEffect, nextTick } from 'vue'
import { Icon } from '@/components/icon'
import { Select } from '@/components/select'
import { useFieldStore } from '@/components/form'
import { placementWhileList } from '@vexip-ui/mixins'
import {
  useNameHelper,
  useProps,
  useLocale,
  booleanProp,
  booleanStringProp,
  sizeProp,
  stateProp,
  createSizeProp,
  createStateProp,
  eventProp,
  emitEvent
} from '@vexip-ui/config'
import { isNull } from '@vexip-ui/utils'

import type { PropType } from 'vue'
import type { Placement } from '@vexip-ui/mixins'
import type { OptionKeyConfig, OptionState, RawOption } from '@/components/option'

export default defineComponent({
  name: 'AutoComplete',
  components: {
    Icon,
    Select
  },
  props: {
    size: sizeProp,
    state: stateProp,
    transfer: booleanStringProp,
    value: [String, Number],
    options: Array as PropType<RawOption[]>,
    filter: {
      type: [Boolean, Function] as PropType<
        | boolean
        | ((value: string | number, options: { label: string, value: string | number }) => boolean)
      >,
      default: null
    },
    prefix: Object,
    prefixColor: String,
    suffix: Object,
    suffixColor: String,
    placeholder: String,
    disabled: booleanProp,
    transitionName: String,
    dropDisabled: booleanProp,
    placement: String as PropType<Placement>,
    clearable: booleanProp,
    ignoreCase: booleanProp,
    autofocus: booleanProp,
    spellcheck: booleanProp,
    keyConfig: Object as PropType<Omit<OptionKeyConfig, 'label'>>,
    onSelect: eventProp<(value: string | number, data: RawOption) => void>(),
    onInput: eventProp<(value: string) => void>(),
    onChange: eventProp<(value: string | number, data: RawOption) => void>(),
    onToggle: eventProp<(visible: boolean) => void>(),
    onEnter: eventProp<(value: string | number) => void>(),
    onClear: eventProp()
  },
  emits: ['update:value'],
  setup(_props, { slots, emit }) {
    const { idFor, state, validateField, clearField, getFieldValue, setFieldValue } = useFieldStore<
      string | number
    >(() => control.value?.focus())

    const props = useProps('autoComplete', _props, {
      size: createSizeProp(),
      state: createStateProp(state),
      transfer: false,
      value: {
        default: () => getFieldValue(''),
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      filter: false,
      prefix: null,
      prefixColor: '',
      suffix: null,
      suffixColor: '',
      placeholder: null,
      disabled: false,
      transitionName: 'vxp-drop',
      dropDisabled: false,
      placement: {
        default: 'bottom',
        validator: (value: Placement) => placementWhileList.includes(value)
      },
      clearable: false,
      ignoreCase: false,
      autofocus: false,
      spellcheck: false,
      keyConfig: () => ({})
    })

    const nh = useNameHelper('auto-complete')

    const currentValue = ref(props.value)
    const currentIndex = ref(-1)
    const visible = ref(false)

    const select = ref<InstanceType<typeof Select> | null>(null)
    const control = ref<HTMLInputElement | null>(null)

    let changed = false
    // eslint-disable-next-line vue/no-setup-props-destructure
    let lastValue = props.value

    const optionsStates = computed<OptionState[]>(() => {
      return select.value?.optionStates ?? []
    })
    const filteredOptions = computed(() => {
      return optionsStates.value.filter(({ hidden }) => !hidden)
    })
    const inputValue = computed(() => {
      const hittingOption = filteredOptions.value[currentIndex.value]

      if (hittingOption) {
        return String(hittingOption.value)
      } else if (control.value?.value) {
        return control.value.value
      } else if (select.value) {
        if (select.value.currentVisible) {
          return currentValue.value?.toString()
        }

        const currentOption = filteredOptions.value.find(
          ({ value }) => value === currentValue.value
        )

        return String(currentOption ? currentOption.value : currentValue.value)
      }

      return String(currentValue.value)
    })
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix)
    })
    const hasSuffix = computed(() => {
      return !!(slots.suffix || props.suffix)
    })

    watch(
      () => props.value,
      value => {
        currentValue.value = value
        lastValue = value
      }
    )
    watch(currentIndex, computeHittding)
    watch(visible, value => {
      if (!value) {
        currentIndex.value = -1
        control.value?.blur()
      } else {
        control.value?.focus()
      }
    })
    watchEffect(() => {
      if (props.filter) {
        const value = currentValue.value

        if (isNull(value)) {
          optionsStates.value.forEach(state => {
            state.hidden = false
          })
        } else {
          if (typeof props.filter === 'function') {
            const filter = props.filter

            optionsStates.value.forEach(state => {
              state.hidden = !filter(value, state)
            })
          } else {
            if (props.ignoreCase) {
              const ignoreCaseValue = value?.toString().toLocaleLowerCase()

              optionsStates.value.forEach(state => {
                state.hidden = !state.value
                  ?.toString()
                  .toLocaleLowerCase()
                  .includes(ignoreCaseValue)
              })
            } else {
              optionsStates.value.forEach(state => {
                state.hidden = !state.value?.toString().includes(value?.toString())
              })
            }
          }
        }

        computeHittding()
      }
    })

    function computeHittding() {
      let index = -1

      optionsStates.value.forEach(state => {
        if (!state.hidden) {
          index += 1
          state.hitting = currentIndex.value === index

          if (state.hitting) {
            if (control.value) {
              control.value.value = String(state.value)
            }
          }
        } else {
          state.hitting = false
        }
      })
    }

    function handleSelect(value: string | number, data: RawOption) {
      if (isNull(value)) {
        return
      }

      const prevValue = currentValue.value
      currentValue.value = value

      emitEvent(props.onSelect, value, data)

      if (value !== prevValue) {
        changed = true
        handleChange()
      } else {
        visible.value = false
      }
    }

    function handleInput(event: string | Event) {
      const value = typeof event === 'string' ? event : (event.target as HTMLInputElement).value

      visible.value = !props.dropDisabled
      currentValue.value = value
      changed = true

      if (currentIndex.value !== -1) {
        currentIndex.value = 0
      }

      emitEvent(props.onInput, value)
    }

    function handleInputChange(event: string | Event) {
      const value = typeof event === 'string' ? event : (event.target as HTMLInputElement).value
      let matchedOption: OptionState | undefined

      if (props.ignoreCase) {
        const noCaseValue = value.toLocaleLowerCase()

        matchedOption = filteredOptions.value.find(
          option => !option.disabled && String(option.value).toLocaleLowerCase() === noCaseValue
        )
      } else {
        matchedOption = filteredOptions.value.find(
          option => !option.disabled && option.value === value
        )
      }

      if (matchedOption) {
        currentValue.value = matchedOption.value
        handleChange()
      }
    }

    function handleChange() {
      if (!changed || currentValue.value === lastValue) return

      changed = false
      lastValue = currentValue.value

      const option = optionsStates.value.find(option => option.value === lastValue)

      setFieldValue(currentValue.value)
      emitEvent(props.onChange, currentValue.value, option?.data || null!)
      emit('update:value', currentValue.value)
      validateField()

      visible.value = false
      control.value?.blur()
    }

    function handleToggle() {
      testOptionCanDrop()
      emitEvent(props.onToggle, visible.value)

      if (!visible.value) {
        currentIndex.value = -1
      }
    }

    function testOptionCanDrop() {
      if (!filteredOptions.value.length || props.dropDisabled) {
        visible.value = false
      }
    }

    function handleKeyDown(event: KeyboardEvent) {
      const key = event.code || event.key

      if (key === 'ArrowDown' || key === 'ArrowUp') {
        event.preventDefault()
        event.stopPropagation()

        currentIndex.value += key === 'ArrowDown' ? 1 : key === 'ArrowUp' ? -1 : 0
        currentIndex.value = Math.min(
          Math.max(-1, currentIndex.value),
          filteredOptions.value.length - 1
        )
      } else {
        if (['Space', ' '].includes(key)) {
          event.stopPropagation()
        }

        if (!['Enter', 'ArrowLeft', 'ArrowRight'].includes(key)) {
          // 进行了其他按键则重置
          currentIndex.value = -1
        }
      }
    }

    function handleEnter() {
      if (filteredOptions.value.length) {
        const option = filteredOptions.value[currentIndex.value === -1 ? 0 : currentIndex.value]

        handleSelect(option.value, option.data)
      } else {
        handleChange()
      }

      emitEvent(props.onEnter, currentValue.value)
      control.value?.blur()
      visible.value = false
    }

    function handleClear() {
      if (props.clearable) {
        const prevValue = currentValue.value

        currentValue.value = ''
        visible.value = false

        if (!isNull(prevValue) && prevValue !== currentValue.value) {
          changed = true
        }

        handleChange()
        emitEvent(props.onClear)
        nextTick(clearField)
      }
    }

    return {
      props,
      nh,
      locale: useLocale('input'),
      idFor,
      currentValue,
      currentIndex,
      visible,

      inputValue,
      hasPrefix,
      hasSuffix,

      select,
      control,

      handleSelect,
      handleInput,
      handleInputChange,
      handleChange,
      handleToggle,
      handleKeyDown,
      handleEnter,
      handleClear
    }
  }
})
</script>
